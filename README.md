# Meesterproef Read.me

## Inhoudsopgave
- [Introductie](#introductie)
- [Door de weken heen](#weken)
  - [Week 1](#week1)
  - [Week 2](#week2)
  - [Week 3](#week3)
  - [Week 4](#week4)
  - [Week 5](#week5)
- [Reflectie](#reflectie)-
  - [Het proces](#proces)
  - [Hoe mijn team en ik de lesstof uit de vakken heb ingezet](#lesstof)
  - [Waar ik in ben verbeterd](#geleerd)

## Introductie <a name="introductie"></a>
Daniël, Martijn en ik hebben voor de case 'bRAIN' gekozen. bRAIN is het project rondom het koppelen van weerberichten aan wateropvang/gebruik in de tuin.

Weersextremen in Nederland nemen steeds verder toe. Enerzijds komen periode van droogte tekorten vaker voor en anderzijds hebben we vaker te maken met extreme neerslag, met wateroverlast tot gevolg. Hier willen we als Nederland zijnde op voorbereid zijn. In de gemiddelde gemeente is 50 tot 60 procent van het totaal oppervlak privaat terrein. Daarom is het essentieel dat ook de private ruimte klimaatadaptief wordt ingericht. Dit betekent dat je bewoners moet overtuigen om klimaatadaptief te worden. Een van de manieren om dit te doen waarin je zowel droogte als extreme neerslag voor een deel kan bufferen is doormiddel van regentonnen.

## Door de weken heen <a name="weken"></a>

### Week 1 <a name="week1"></a>

#### De eerste stand-up
In week 1 hebben we de taken verdeeld. Ik ben de man van het design, Martijn is goed in server-side developing en Daniel is goed in Front-End in het algemeen. We hebben besloten de SCRUM tactiek te gebruiken om de taken binnen het project onder elkaar te verdelen, en om bij te houden waar we zijn binnen het project. We hebben elke maandag een stand-up gehouden.

#### Briefing
We zijn als team langs onze opdrachtgever SPATwater geweest. We hebben natuurlijk de opdracht al gelezen op de wiki, maar we wilden toch wat meer weten en we hadden nog wat vragen. Ik heb tijdens de meeting de volgende notities gemaakt. Klimaatadaptatie = Aanpassen op klimaat/inspelen op klimaat Neerslag neemt toe, het regent steeds harder. Ook is er steeds meer droogte, waardoor je hier goed op moet kunnen aanpassen. Aardswetenschappen gestudeerd, master hydrologie. Een tool ontwikkelen op het moment dat mensen een regenton hebben, zodat ze een idee krijgen wanneer ze die moeten legen voordat er weer een bui komt. Een systeem waar water goed wordt vastgehouden. Regenton moet leeg zijn voordat er weer een nieuwe regenbui komt, zodat het water zo veel mogelijk vastgehouden wordt voordat het weg gevoerd wordt. Met regenpijpen moeilijk om de oppervlakte te meten, de daken zijn makkelijk te meten. Eerst kijken naar hoeveel vierkante meter dak je hebt, dan de regenpijpen en dat x4. Voorspellen hoeveel water er in een regenton komt. Belangrijk

Weer kunnen meenemen in de applicatie, aan de hand van KNMI
Aan de hand van deze data zien of het weer gaat regenen, waarschuwen dat de regenton opengezet wordt.
Gebruiksvriendelijkheid
Bewoners meekrijgen in dit verhaal
Makkelijk te gebruiken
Visueel aantrekkelijk
Goed prototype kunnen presenteren
Hoofddoel: bewoners omverblazen met idee
App moet optijd een seintje geven wanneer de ton vol raakt SPATwater verkoopt idee aan gemeente, gemeente verkoopt idee aan bewoners App: Perceelwijzer KNMI API eerst testen, bel ze vooral! Vrijdag 1 -2, aankomende vrijdag digitaal. Om de week fysiek. Wachtwoord WIFI: Carbon2021

#### De-briefing
Samen met Daniel en Martijn heb ik aan de de-briefing gezeten. We hebben dit gedaan om de opdracht te verduidelijk voor beide ons en SPATwater. Dit is de de-briefing:

##### Contactgegevens
Timo van den Berg t.vdberg@spatwater.nl Mees van Milligen de Wit m.vmilligen@spatwater.nl Jesse Schoenmakers j.schoenmakers@spatwater.nl

##### Achtergrondinformatie
30 Mei zijn we voor het eerst langs geweest bij SPATwater in Noord. Hier hebben we kennis mogen maken met drie van de vier werknemers van SPATwater, namelijk Mees, Mees en Jesse. SPATwater is ontstaan toen Mees en Jesse afstudeerden van de master hydrologie. Ze zijn toen begonnen met het opzetten van het bedrijf. Het bedrijf houdt zich voornamelijk bezig met klimaatadaptatie, een cruciaal onderwerp gezien de toename van hevige regenbuien en periodes van droogte. Normaal gesproken geeft het bedrijf adviezen op het gebied van water aan gemeenten door het hele land, maar nu hebben ze een nieuw project. Hiervoor zijn wij ingeschakeld.

##### Opdrachtomschrijving
SpatWater wilt een applicatie waarin gebruikers een regenton kunnen instellen. Aan de hand van de locatie en het weer wordt de regenton digitaal gevuld, en weet de gebruiker de hoeveelheid water in de regenton. Veel water raakt namelijk verloren in het riool door dat regenpijpen rechtstreeks het riool in gaan. Met deze oplossing wordt er meer water afgevoerd in de grond en wordt er ook minder drinkwater verspilt.

##### Aanleiding
Omdat het klimaat zo aan het veranderen is en er tegenwoordig steeds hevigere regenbuien zijn en periodes van droogtes, wilt onze opdrachtgever meer gebruik gaan maken van regentonnen. Dit om meer regenwater op te vangen en dit in de tuin te laten lopen. Het is namelijk zo dat veel van het regenwater nu het riool inloopt en vervolgens wordt gedumpt in sloten en rivieren. Hierdoor verdwijnt het water uiteindelijk in de zee en wordt het zout. Het is dus beter als het regenwater bijvoorbeeld voor het besproeien van de tuin wordt gebruikt en in het grondwater verdwijnt.

##### Projectdoel
SPATwater heeft ons gevraagd een applicatie te ontwikkelen waarbij bewoners een regenton kunnen instellen en met deze applicatie kunnen zien hoeveel regenwater zij hebben opgevangen in de regenton. Hiermee krijgen de bewoners hulp bij het beheren van de opslag van het regenwater. Er zal een melding worden verstuurd wanneer de regenton geleegd moet worden zodat er maximaal water kan worden opgevangen en minder water wordt verspild.

##### Doelstelling
De doelstelling van het bedrijf is het voorkomen van waterverspilling doormiddel van het gebruik van regentonnen of andere klimaatbewuste implementeringen. Ook willen ze de kwaliteit van water zo goed houden als mogelijk in Nederland.

##### Oplevering
De applicatie zal de weersvoorspellingen van openMeteo integreren om te kunnen anticiperen op komende regenbuien. Gebruiksvriendelijkheid is hierbij cruciaal; we willen dat de tool makkelijk te gebruiken en visueel aantrekkelijk is. Het prototype moet indrukwekkend zijn - we willen de bewoners omverblazen met ons idee. De app moet tijdig meldingen sturen wanneer de regenton vol dreigt te raken. Ook moet de gemeente Amsterdam

##### Randvoorwaarden
Het project zal ook uitdagingen met zich meebrengen, zoals het bepalen of het dak schuin of plat is. Hiermee krijg je te maken met verdamping van water waardoor de accuraatheid van de hoeveelheid water in de regenton moeilijker te bepalen wordt. Hierdoor kunnen verkeerde voorspellingen worden gemaakt. Ook kan het zijn dat er meerdere regenpijpen zijn en dat niet elke regenpijp is aangesloten op een regenton. De bewoners staan centraal en hier moet ook op gefocust worden. Als de applicatie niet fijn te gebruiken is door bewoners is het niet functioneel.

##### Gebruikers van het eindresultaat
Onze gebruikers van het eindresultaat zullen klimaatbewust bezig zijn met water. Ze verspillen minder drinkwater en zorgen ervoor dat er meer grondwater in de grond komt. Hierdoor dragen ze bij aan een verbeterd milieu. De bewoners staan centraal en dit is ook de gebruiker. Ook de gemeente Amsterdam moet inzicht kunnen hebben echter moeten we focussen op de gebruiker.

##### Relatie met andere projecten
Er is al een soortgelijke app beschikbaar genaamd Perceelwijzer, waarin je data kan krijgen over verschillende percelen in Nederland. Denk hierbij aan bijvoorbeeld neerslag maar ook of er gemaaid mag worden. Deze app maakt dus al gebruik van het aantal mm neerslag dat er per perceel valt. Wij zullen ook zoiets moeten integreren, maar wij gebruiken hiervoor de KNMI API.

#### Het begin van het design
Als eerst ben ik gaan kijken naar hoe onze web app gedesigned zou moeten worden. Ik heb hierbij de core-functionaliteit van de app meegebracht. Wij hebben als team besloten dat de core-functionaliteit is dat de gebruiker binnen de app een regenton kan aanmaken en dat de gebruiker kan zien hoeveel regen er in de regenton valt, zodat de gebruiker tijdig zijn regenton kan legen en er dus geen water wordt verspilt.

Mijn eerste concept houdt hier rekening mee.

Ik heb een homepage gemaakt waarin de core-functionaliteit centraal staat. De gebruiker kan zien hoeveel water er in zijn regenton zit, en kan de regenton legen zodra deze vol begint te raken. Ik heb ook een state gemaakt waarin de de regenton leeg is. Daarnaast is er een state dat de regenton geleegd moet worden. De app geeft de gebruiker dan een melding dat de regenton bijna vol is, en dat deze geleegd moet worden voordat het water verspilt wordt. Verder hebben we een state toegevoegd waar de regenton al leeg is. De app geeft de gebruiker dan een melding dat de regenton niet geleegd kan worden omdat de regenton al geleegd is. Vervolgens heb ik een pagina gemaakt waar de gebruiker kan kijken naar de gegevens van de regenpijpen die aangesloten zijn aan zijn regenton, de hoeveelheid regentonnen en hoeveel liter deze bevatten en hoe groot zijn dak is. Als laatst heb ik een menu toegevoegd waarin de gebruiker naar andere delen van de app kan navigeren.

<img src="/images-productbio/versie-1/alles-geheel.png" width:500px>

#### Iteratie 1 Presenteren
Tijdens de presentatie van week 1 hebben we te horen gekregen dat ze het erg knap vonden dat we al iets met code hadden gedaan. Ze wilden voor de regenton alleen echt een design hebben. Verder waren ze tevreden.

### Week 2 <a name="week2"></a>

#### Design Versie 
Ik heb voorgesteld een onboarding toe te voegen aan het design, zodat de gebruiker een introductie krijgt tot de app en zodat de gebruiker meteen informatie kan invullen over zijn of haar regenton. Hiervoor heb ik het volgende design gemaakt.

<img src="/images-productbio/versie-2/onboarding-geheel.png" width:500px>

Daarnaast heb ik nog een pagina toegevoegd waarin gebruikers de feedback krijgen wanneer ze nog geen regenton hebben geïmplementeerd.

#### Onboarding in code
Ik heb ook de taak op me genomen om de onboarding the maken. Hier heb ik een begin voor gemaakt in HTML. Ik heb hiervoor eerst een structuur geschetst.

<img src="/images-productbio/other/fieldset-inclusief-input.jpg" width:500px>
<img src="/images-productbio/other/fieldset-inclusief-uitleg.jpg" width:500px>

Daarna ben ik de structuur om gaan zetten tot HTML code. Dit is hoe een fieldset voor de eerste twee schermen in het onboarding proces er uit kwamen te zien. Tijdens het maken van de HTML leek het mij ook een leuk idee om een plaatje toe te voegen aan de eerste twee stappen, om de pagina minder saai te maken en om de uitleg iets visueler te maken voor de gebruiker. Het enige verschil tussen de tweede en eerste pagina van de onboarding is dat de eerste pagina alleen een volgende button heeft, met de logische reden dat de terug button in de eerste pagina gewoon niet nodig is.

```js
<fieldset id="fieldset1">
                    <div class="heading-text">
                        <h1>bRAIN</h1>
                        <img src="./images/onboarding-image-1.jpg">
                    </div>
                    <div class="text-button-progress">
                        <h2>Welkom</h2>
                        <label for="volgende">Welkom bij bRAIN! Dit is een app waarin je makkelijk kan zien wanneer je regenton vol raakt. De app geeft je een tijdige waarschuwing wanneer dit gebeurt.</label>
                        <button class="volgende-button" id="fieldset1-volgende-button">Volgende</button>
                        <div class="progress">
                            <div class="stap"></div>
                            <div class="stap"></div>
                            <div class="stap"></div>
                            <div class="stap"></div>
                            <div class="stap"></div>
                        </div>
                    </div>
                </fieldset>
```

Dit is hoe een fieldset voor de laatste drie schermen in het onboarding proces er uit kwamen te zien. 

```js
<fieldset id="fieldset4">
                    <div class="heading-text">
                        <h1>bRAIN</h1>
                        <p>Om uit te rekenen hoeveel water er per dag ongeveer in jouw regenton terechtkomt, hebben we wat informatie van je nodig.</p>
                    </div>
                    <div class="text-label">
                        <label for="boardingDak">Hoe groot is je dak in m²?</label>
                        <input type="number" id="boardingDak" name="boardingDak" required>
                        <span class="error-message"></span>
                    </div>
                    <div class="button-progress">
                        <div class="buttons">
                            <button class="terug-button" id="fieldset4-terug-button">Terug</button>
                            <button class="volgende-button" id="fieldset4-volgende-button">Volgende</button>
                        </div>
                        <div class="progress">
                            <div class="stap"></div>
                            <div class="stap"></div>
                            <div class="stap"></div>
                            <div class="stap"></div>
                            <div class="stap"></div>
                        </div>
                    </div>
                </fieldset>
```

### Week 3 <a name="week3"></a>

#### Design Versie 3
In deze versie van het design ben ik vooral gaan focussen op de look en feel van het ontwerp. We hebben gemerkt dat de opdrachtgever dacht dat het design nog iets te lo-fi was. Vandaar dat ik heb besloten om de hele huisstijl om te gooien. Ik heb hiervoor eerst een kleine style guide gemaakt, waarin de opdrachtgever kan zien welke fonts we hebben gebruikt, hoe de knoppen eruit zien, een vers design van de regenton, de kleuren en een eventueel logo.

<img src="/images-productbio/versie-2/huisstijl.jpg" width:500px>

Aan de hand van deze huisstijl ben ik aan het redesign van de onboarding gaan werken. Ik heb hierbij ook een scherm toegevoegd waarin de gebruiker kan selecteren wat voor dak hij of zij in bezit heeft, aangezien dit veel invloed heeft op hoeveel water er terecht komt in de regenton. Dit is hoe de onboarding er nu is uit komen zien:

<img src="/images-productbio/versie-3/onboarding-v3.png" width:500px>

#### Onboarding in code

Na het redesignen van de onboarding ben ik meteen aan de slag gegaan met de CSS inplaats van dat ik eerst de eerste versie van het design ging vormgeven met CSS. Dit is hoe de CSS er uiteindelijk uit kwam te zien:

```css
.onboarding {
    width: 85vw;
    margin: auto;
}

fieldset {
    position: relative;
    border: none;
}

#fieldset1, #fieldset2 {
    height: 100vh;
    display: grid;
    grid-template-rows: auto auto;
    align-content: space-between;
}

#fieldset1 .text-button-progress, #fieldset2 .text-button-progress {
    display: grid;
    grid-gap: 1.5em;
}

#fieldset3, #fieldset4, #fieldset5, #fieldset6 {
    height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr auto;
    align-content: space-between;
}

fieldset h1 {
    color: var(--dark-blue);
    font-family: 'Bree Serif', serif;
    font-size: 3em;
    font-weight: 400;
    text-align: center;
}

fieldset img {
    width: 100vw;
}

fieldset .volgende-button {
    background-color: var(#3498DB);
}

h2 {
    padding: 1em;
    text-align: center;
}

fieldset h2 {
    text-align: left;
    color: var(--dark-blue);
    font-family: 'Bree Serif', serif;
    font-size: 2em;
    font-weight: 400;
    padding: 0;
}

fieldset label {
    color: var(--dark-blue);
    font-family: var(--open-sans);
    font-size: 1.2em;
    font-weight: 400;
    line-height: 1.4;
}

fieldset p {
    color: var(--dark-blue);
    font-family: var(--open-sans);
    font-size: 1.2em;
    font-weight: 400;
}

fieldset img {
    width: 100%;
}

fieldset .button-progress {
    display: grid;
    grid-template-rows: 1fr 1fr;
    width: 100%;
    grid-gap: 1.5em;
}

fieldset .buttons {
    width: 100%;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-column-gap: 0.5em;
}

fieldset .terug-button {
    color: var(--green);
    font-family: 'Bree Serif', serif;
    font-size: 1.4em;
    background-color: var(--white);
    border: solid 2px var(--green);
    border-radius: 20em;
    width: 100%;
    height: 3em;
}

fieldset .volgende-button {
    color: var(--white);
    font-family: 'Bree Serif', serif;
    font-size: 1.4em;
    background: linear-gradient(var(--green), var(--darker-green));
    border: none;
    border-radius: 20em;
    width: 100%;
    height: 3em;
}

fieldset .rondaf-button {
    color: var(--white);
    font-family: 'Bree Serif', serif;
    font-size: 1.4em;
    background: linear-gradient(var(--green), var(--darker-green));
    border: none;
    border-radius: 20em;
    width: 100%;
    height: 3em;
}

fieldset .progress {
    display: grid;
    place-items: center;
    grid-template-columns: repeat(5, 1fr);
    width: 60vw;
    height: 4em;
    margin: auto;
}

fieldset input {
    font-family: 'Bree Serif', serif;
    width: 100%;
    font-size: 1.4em;
    border-radius: 0.6em;
    border: none;
    margin-top: 0.4em;
    padding: 0.8em;
    background-color: var(--grey);
    color: var(--green);
}

fieldset input:focus {
    border: none;
    outline: none;
}

label[for=boardingDak], label[for=boardingPijpen], label[for=boardingTonnen], label[for=soort-dak] {
    font-family: 'Bree Serif', serif;
    font-size: 1.4em;
}


#fieldset3 .text-label {
    width: 100%;
}

#fieldset3 .label[for=soort-dak] {
    color: var(--dark-blue);
    font-family: 'Bree Serif', serif;
    font-size: 2em;
    font-weight: 400;
    padding: 0;
}

#fieldset3 .text-label .soort-dak {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-gap: 0.5em;
    margin-top: 0.4em;
}

#fieldset3 .plat {
    grid-column: span 2;
    text-align: center;
}

fieldset .punt, .schuin, .plat {
    display: grid;
    justify-content: center;
    align-items: center;
    background-color: var(--grey);
    border-radius: 0.5em;
    padding: 1em;
    width: 100%;
    height: 10em;
}

label[for=punt], label[for=schuin], label[for=plat] {
    text-align: center;
}

label[for=punt] img, label[for=schuin] img, label[for=plat] img {
    margin-bottom: 0.4em;
}

fieldset .punt input[type="radio"], .schuin input[type="radio"], .plat input[type="radio"] {
    display: none;
}

fieldset .punt:has(input[type="radio"]:checked), .schuin:has(input[type="radio"]:checked), .plat:has(input[type="radio"]:checked) {
    background-color: #e0e0e0;
}

#fieldset2, #fieldset3, #fieldset4, #fieldset5, #fieldset6 {
    display: none;
}
```

#### Code review met Joost
Omdat ik vooral nog bezig was met het design van de applicatie, gaf Joost dringend het advies om de code in te gaan duiken.

#### Design review met Vasilis
Vasilis leek erg tevreden met het design. Eigenlijk was er in voor dit deel in het proces niet heel veel feedback gegeven.

### Week 4 <a name="week4"></a>

#### Design Versie 4  
Ik heb de huisstijl uiteindelijk toegepast op de schermen die we al hadden gemaakt. Dit is hoe alles er uiteindelijk uit heeft komen te zien.

<img src="/images-productbio/versie-3/geheel-zonder-feedback-v3.png" width:500px>

Ik heb wel een aantal dingen aangepast aan de vorige schermen. Bijvoorbeeld, ik heb het menu omgezet van een hamburger menu die open klapt naar een menu dat onderaan het scherm zat. Ik heb deze keuze gemaakt omdat er niet veel links in het menu hoeven te staan, waardoor de gebruiker gewoon via de homepagina naar de gegevens en statistieken pagina kan navigeren. Verder heb ik de statistieken pagina uitgebreid. Ik heb een staafdiagram gemaakt, maar als team hebben we uiteindelijk besloten deze niet mee te nemen in het ontwerp, aangezien het ons onrealistisch leek om dit met code te realiseren in de tijd die we nog over hadden. Verder heb ik een scherm vormgegeven waarin de gebruiker feedback krijgt op basis van hoe vol zijn regenton zit. Hoe meer water er in de regenton blijft zitten, hoe droger de grond wordt. Wanneer het in het echt regent is regent het ook in de app aan de hand van een animatie.

<img src="/images-productbio/versie-3/feedback-v3.png" width:500px>

Dit heb ik samen met Daniel gerealiseerd aan de hand van code. We zijn de regen gif gaan koppelen aan de precipitation sum. Wanneer deze hoger is dan 1mm krijg je de regenanimatie te zien die hierboven ook te zien is. Hieronder zie je de code die we daarvoor hebben gebruikt.

```js
const isRaining = weatherData.daily.precipitation_sum[0] > 1;
```

#### Onboarding in code
Ik ben daarnaast verder gaan werken aan de code voor de onboarding. Ik heb de HTML en CSS afgerond, dus ik ben begonnen met de JavaScript. JavaScript is altijd een uitdaging voor mij, dus ik wist al dat dit best veel tijd ging kosten. Dit is hoe de code er uit is komen te zien. Belangrijk om te weten is dat ik deze code voor een paar dagen niet kon testen, omdat er nog wat problemen in de JavaScript code van Martijn en Daniel zaten die eerst opgelost moesten worden voordat ik de code kon testen.

```js
const fieldset1 = document.getElementById('fieldset1');
const fieldset2 = document.getElementById('fieldset2');
const fieldset3 = document.getElementById('fieldset3');
const fieldset4 = document.getElementById('fieldset4');
const fieldset5 = document.getElementById('fieldset5');

const fieldset1VolgendeKnop = document.getElementById('fieldset1-volgende-knop');
const fieldset2TerugKnop = document.getElementById('fieldset2-terug-knop');
const fieldset2VolgendeKnop = document.getElementById('fieldset2-volgende-knop');
const fieldset3TerugKnop = document.getElementById('fieldset3-terug-knop');
const fieldset3VolgendeKnop = document.getElementById('fieldset3-volgende-knop');
const fieldset4TerugKnop = document.getElementById('fieldset4-terug-knop');
const fieldset4VolgendeKnop = document.getElementById('fieldset4-volgende-knop');
const fieldset5TerugKnop = document.getElementById('fieldset5-terug-knop');
const fieldset5VolgendeKnop = document.getElementById('fieldset5-volgende-knop');

const fieldsetStap1 = document.getElementById('fieldset-stap1');
const fieldsetStap2 = document.getElementById('fieldset-stap2');
const fieldsetStap3 = document.getElementById('fieldset-stap3');
const fieldsetStap4 = document.getElementById('fieldset-stap4');
const fieldsetStap5 = document.getElementById('fieldset-stap5');

fieldset1VolgendeKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset1.style.display = "none";
    fieldset2.style.display = "block";

    fieldsetStap1.style.width = "0.6em";
    fieldsetStap1.style.height = "0.6em";
    fieldsetStap1.style.backgroundColor = "#EDEDED";
    fieldsetStap2.style.width = "1.2em";
    fieldsetStap2.style.height = "1.2em";
    fieldsetStap2.style.backgroundColor = "#36A734";
});

fieldset2TerugKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset1.style.display = "block";
    fieldset2.style.display = "none";

    fieldsetStap2.style.width = "0.6em";
    fieldsetStap2.style.height = "0.6em";
    fieldsetStap2.style.backgroundColor = "#EDEDED";
    fieldsetStap1.style.width = "1.2em";
    fieldsetStap1.style.height = "1.2em";
    fieldsetStap1.style.backgroundColor = "#36A734";
});

fieldset2VolgendeKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset2.style.display = "none";
    fieldset3.style.display = "block";

    fieldsetStap2.style.width = "0.6em";
    fieldsetStap2.style.height = "0.6em";
    fieldsetStap2.style.backgroundColor = "#EDEDED";
    fieldsetStap3.style.width = "1.2em";
    fieldsetStap3.style.height = "1.2em";
    fieldsetStap3.style.backgroundColor = "#36A734";
});

fieldset3TerugKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset2.style.display = "block";
    fieldset3.style.display = "none";

    fieldsetStap3.style.width = "0.6em";
    fieldsetStap3.style.height = "0.6em";
    fieldsetStap3.style.backgroundColor = "#EDEDED";
    fieldsetStap2.style.width = "1.2em";
    fieldsetStap2.style.height = "1.2em";
    fieldsetStap2.style.backgroundColor = "#36A734";
});

fieldset3VolgendeKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset3.style.display = "none";
    fieldset4.style.display = "block";

    fieldsetStap3.style.width = "0.6em";
    fieldsetStap3.style.height = "0.6em";
    fieldsetStap2.style.backgroundColor = "#EDEDED";
    fieldsetStap4.style.width = "1.2em";
    fieldsetStap4.style.height = "1.2em";
    fieldsetStap4.style.backgroundColor = "#36A734";
});

fieldset4TerugKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset3.style.display = "block";
    fieldset4.style.display = "none";

    fieldsetStap4.style.width = "0.6em";
    fieldsetStap4.style.height = "0.6em";
    fieldsetStap4.style.backgroundColor = "#EDEDED";
    fieldsetStap3.style.width = "1.2em";
    fieldsetStap3.style.height = "1.2em";
    fieldsetStap3.style.backgroundColor = "#36A734";
});

fieldset4VolgendeKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset4.style.display = "none";
    fieldset5.style.display = "block";

    fieldsetStap4.style.width = "0.6em";
    fieldsetStap4.style.height = "0.6em";
    fieldsetStap4.style.backgroundColor = "#EDEDED";
    fieldsetStap5.style.width = "1.2em";
    fieldsetStap5.style.height = "1.2em";
    fieldsetStap5.style.backgroundColor = "#36A734";
});

fieldset5TerugKnop.addEventListener('click', function(event) {
    event.preventDefault();

    fieldset4.style.display = "block";
    fieldset5.style.display = "none";

    fieldsetStap5.style.width = "0.6em";
    fieldsetStap5.style.height = "0.6em";
    fieldsetStap5.style.backgroundColor = "#EDEDED";
    fieldsetStap4.style.width = "1.2em";
    fieldsetStap4.style.height = "1.2em";
    fieldsetStap4.style.backgroundColor = "#36A734";
});
```

#### Code review met Robert
Robert vond dat ik prima onderweg was. Ik wist eerst niet waarom de bovenstaande JavaScript code niet werkte, dus ik vroeg wat mogelijk het probleem was. Hierdoor kwam ik erachter dat er een probleem zat in Martijn en Daniels code. Verder kon de bovenstaande code volgens Robert veel korter.

#### Design review met Sanne
Omdat we zo goed als aan het einde van het maken van het ontwerp waren, konden we goed feedback krijgen op wat we hadden om te zien waar mogelijke verbeteringen in zaten. Als eerst gaf Sanne mij de feedback om het menu om te zetten naar een hub and spoke menu. Dit houdt in dat het menu onderaan verdwijnt zodra er bijvoorbeeld op de 'gegevens' icoon wordt getikt. In plaats van het menu verschijnt er dan een pijltje linksboven het scherm. Zodra de gebruiker op dit pijltje klikt wordt hij terug gebracht naar de homepagina. De logica achter dit is dat er meer schermruimte vrij komt en omdat het toch niet vaak voorkomt dan de gebruiker van bijvoorbeeld de gegevens pagina naar de statistieken pagina gaat.

<img src="/images-productbio/other/hub-and-spoke.png" width:500px>

Verder was het belangrijk om na te denken over hoe we het menu implementeren in iOS of Android. Android mobielen hebben namelijk een menu onderaan het scherm staan waarmee de gebruiker terug kan naar een andere pagina. Op iOS staat dit vaak linksboven het scherm in de vorm van een pijl terug. Ook was het handig om na te denken over hoe we gebruiker kunnen helpen met het meten van zijn dak. Nu is het nogal onduidelijk voor de gebruiker hoe hij dat zou moeten doen. Verder was het volgens Sanne niet nodig om in de gegevens pagina de gegevens te kunnen aanpassen, maar dat er een knop onder de gegevens staat die de gebruiker weer terug leid naar de onboarding, waarin hij op deze manier zijn gegevens weer kan aanpassen. Dit was volgens Sanne beter omdat de gebruiker toch haast nooit zijn gegevens gaat veranderen.

### Week 5 <a name="week5"></a>

#### Onboarding in code
Na dat Martijn en Daniel de stuk code die problemen veroorzaakte voor mijn onboarding code, ben ik de code voor mijn onboarding gaan kunnen testen. Ik werd helaas teleurgesteld want de code werkte niet. Dus ik moest een nieuwe aanpak bedenken.

Eerst ben ik alle fieldsets en stappen binnen de DOM gaan opslaan. 'let currentFieldsetIndex = 0;' initialiseert de variabele currentFieldsetIndex met de waarde 0. Deze variabele houdt bij welk fieldset momenteel wordt weergegeven.

```js
const fieldsets = document.querySelectorAll('fieldset');
const stappen = document.querySelectorAll('.stap');
let currentFieldsetIndex = 0;
```

Hieronder staat een functie genaamd showFieldset die een index als parameter accepteert. Deze functie wordt gebruikt om een specifiek fieldset te tonen op basis van de opgegeven index. 'fieldsets.forEach' voert een forEach-lus uit op de fieldsets-array. Voor elk fieldset wordt de meegeleverde callback-functie uitgevoerd. 'if (i === index) { ... } else { ... }' controleert of de huidige iteratie-index overeenkomt met de opgegeven index. Als dat het geval is, wordt het fieldset weergegeven door de display-eigenschap in te stellen op 'grid' en wordt de currentFieldsetIndex bijgewerkt. Anders wordt het fieldset verborgen door de display-eigenschap in te stellen op 'none'. 'updateProgress()' roept de functie updateProgress aan om de voortgangsbalk bij te werken.

```js
function showFieldset(index) {
    fieldsets.forEach((fieldset, i) => {
        if (i === index) {
        fieldset.style.display = 'grid';
        currentFieldsetIndex = index; 
        } else {
        fieldset.style.display = 'none';
        }
    });

    updateProgress();
}
```

Hieronder staat een functie genaamd 'nextFieldset' die wordt uitgevoerd wanneer er op de volgende knop wordt geklikt. Deze functie controleert of er een volgend fieldset is en roept vervolgens de showFieldset-functie aan om het volgende fieldset weer te geven. 'if (currentFieldsetIndex < fieldsets.length - 1) { ... }' controleert of de huidige fieldsetindex kleiner is dan de totale lengte van fieldsets. Dit zorgt ervoor dat de volgende knop alleen werkt als er een volgend fieldset is. 'const isFormValid = validateForm();' roept de functie validateForm aan en slaat het resultaat op in de constante isFormValid. Deze functie controleert of het huidige formulier geldige gegevens bevat. 'currentFieldsetIndex++; showFieldset(currentFieldsetIndex); updateProgress();' verhoogt de waarde van currentFieldsetIndex, roept de showFieldset-functie aan om het volgende fieldset weer te geven en roept vervolgens de updateProgress-functie aan om de voortgangsbalk bij te werken. '

```js
function nextFieldset() {
    if (currentFieldsetIndex < fieldsets.length - 1) {
      const isFormValid = validateForm(); 
  
      if (isFormValid) {
        currentFieldsetIndex++;
        showFieldset(currentFieldsetIndex);
        updateProgress();
      } 
    }
  } 
```

Hieronder staat een functie genaamd 'previousFieldset' die wordt uitgevoerd wanneer er op de vorige knop wordt geklikt. Deze functie controleert of er een vorig fieldset is en roept vervolgens de showFieldset-functie aan om het vorige fieldset weer te geven. 'if (currentFieldsetIndex > 0) { ... }' controleert of de huidige fieldsetindex groter is dan 0. Dit zorgt ervoor dat de terugknop alleen werkt als er een vorig fieldset is. 

```js
function previousFieldset() {
    if (currentFieldsetIndex > 0) {
        currentFieldsetIndex--;
        showFieldset(currentFieldsetIndex);
        updateProgress();
    }
}
```

'const volgendeButtons = document.querySelectorAll('.volgende-button');' selecteert alle elementen met de klasse 'volgende-button' op de pagina en slaat ze op in de constante 'volgendeButtons'. 'volgendeButtons.forEach((button) => { ... })' voegt een event listener toe aan elk element in volgendeButtons. De event listener reageert op een klik op de knop en roept de functie nextFieldset aan. 'const terugButtons = document.querySelectorAll('.terug-button');' selecteert alle elementen met de klasse 'terug-button' op de pagina en slaat ze op in de constante terugButtons. 'terugButtons.forEach((button) => { ... })' voegt een event listener toe aan elk element in terugButtons. De event listener reageert op een klik op de knop en roept de functie previousFieldset aan. 'const rondAfButton = document.getElementById('rondaf-button');' selecteert het element met de id 'rondaf-button' en slaat het op in de constante rondAfButton. 'if (rondAfButton) { ... }' controleert of rondAfButton een waarde heeft. Dit zorgt ervoor dat de code binnen de blokhaak alleen wordt uitgevoerd als er een element is gevonden met de id 'rondaf-button'. 'rondAfButton.addEventListener('click', function(event) { ... })' voegt een event listener toe aan het element met de id 'rondaf-button'. De event listener reageert op een klik op de knop en voert de meegeleverde callback-functie uit. 'const isFormValid = validateForm();' roept de functie validateForm aan en slaat het resultaat op in de constante isFormValid. Deze functie controleert of het huidige formulier geldige gegevens bevat. 'if (!isFormValid) { ... }' controleert of het formulier ongeldige gegevens bevat. Als dat het geval is, wordt het standaardgedrag van de knop voorkomen en wordt de functie beëindigd.

```js
const volgendeButtons = document.querySelectorAll('.volgende-button');
    volgendeButtons.forEach((button) => {
    button.addEventListener('click', function(event) {
        event.preventDefault();
        nextFieldset();
    });
});

const terugButtons = document.querySelectorAll('.terug-button');
    terugButtons.forEach((button) => {
    button.addEventListener('click', function(event) {
        event.preventDefault();
        previousFieldset();
    });
});

const rondAfButton = document.getElementById('rondaf-button');
if (rondAfButton) {
  rondAfButton.addEventListener('click', function(event) {
  const isFormValid = validateForm();

  if (!isFormValid) {
    event.preventDefault();
    return; 
  }
});
}
```

Hieronder staat een functie genaamd 'validateForm' die wordt gebruikt om het huidige fieldset te valideren. De functie controleert of alle invoervelden zijn ingevuld en retourneert een boolean-waarde die aangeeft of het formulier geldig is.

```js
function validateForm() {
    const currentFieldset = fieldsets[currentFieldsetIndex];
    const inputs = currentFieldset.querySelectorAll('input');
    const errorMessages = currentFieldset.querySelectorAll('.error-message');
    let isValid = true;
    
    for (let i = 0; i < inputs.length; i++) {
      if (inputs[i].value === '') {
        errorMessages[i].textContent = 'Dit veld moet worden ingevuld';
        isValid = false;
      } else {
        errorMessages[i].textContent = '';
      }
    }
    
    return isValid;
  }
```

Aan de hand van Roberts feedback heb ik de code ingekort.

#### Feedback van SPATwater op ons eindproduct en teamwerking
Dit team heeft in korte tijd een goed werkend product afgeleverd en de verwachtingen (bovengemiddeld) waargemaakt. Feedback werd goed meegenomen en er is in het product veel aandacht geweest voor verlangd design. Er zitten in het product wel verbeterpunten om tot een eindproduct te komen, maar de core-functionaliteit werkt grotendeels. Alleen het aanpassen van gegevens werkt nog niet optimaal, wat wel core-functionaliteit werd geacht, zoals de grootte van de regenton. Desondanks heeft het team bovengemiddeld gepresteerd en een product afgeleverd waar we als opdrachtgever verder mee kunnen om te voldoen aan de vragen van onze klanten. Het design en animaties sloten aan bij onze wens. Heel erg bedankt team! We zijn erg tevreden.

## Reflectie <a name="reflectie"></a>

### Het proces <a name="proces"></a>
Ik vond het spannend om de meesterproef aan te gaan aangezien ik niet helemaal wist wat ik moest verwachten. Alhoewel ik bijna alle vakken gehaald heb, had elke vak zijn eigen uitdagingen, en ik wist dat elk vak in principe overnieuw doen niet makkelijk ging worden. Gelukkig kan ik zeggen dat ik met mijn team een goed product heb neergezet. De hele minor werk je in je eentje, dus om in teamverband aan de gang te gaan moest je de opdracht wel op een andere manier aanpakken. We hebben bijvoorbeeld gebruik gemaakt van de SCRUM methode om taken te verdelen en om bij te houden wie wat nog moet doen en wat er in het geheel nog gedaan moet worden. Op deze manier hebben we naar mijn idee goed de taken verdeeld. Er waren duidelijk wel wat mensen meer gespecialiseerd in het een dan in het ander. Maar hierdoor konden we wel de taken verdelen op een manier dat iedereen gemotiveerd te werk kon gaan. Ik heb leren omgaan met Figma en ik hoe ik het best me kan voorbereiden op het schrijven van code, omdat ik eerst altijd maar gewoon meteen de code in duik, in plaats van een goed beeld te vormen hoe ik het ontwerp ga neerzetten. Dit bespaarde me tijd.

### Hoe mijn team en ik de lesstof uit de vakken heb ingezet <a name="lesstof"></a>

#### Web App from Scratch
Ik heb veel werk gestopt in het vormgeven van de applicatie. Ik heb hierbij verschillende design principes gebruikt. Ik heb voor de structuur van mijn HTML eerst een schets gemaakt, zodat ik niet tijdens het proces problemen krijg met elementen die ik nog in de HTML moet zetten. Ik heb aan de hand van een API een regen animatie werkend laten krijgen.

#### CSS to the Rescue
Om de onboarding werkend te krijgen heb ik veel moeten experimenteren met grid. Het design neerzetten op Figma is natuurlijk een stuk makkelijker dan om hetzelfde in code te doen. Er zat dus ook een flinke uitdaging in het juist positioneren van de elementen. Ik heb ook flink geëxperimenteerd met animaties, omdat ik zelf eerst een regen animatie wilde maken.

#### Progressive Web Apps
Het team heeft server-side rendering geïmplementeerd met behulp van views en partials. Deze views renderen gegevens vanuit een API-ophaalverzoek. We hebben speciale functies geschreven en in een aparte map geplaatst om dit te faciliteren. Vervolgens hebben we deze gegevens in verschillende functies hergebruikt, zodat er slechts één ophaalverzoek hoeft te worden gedaan. Hierdoor kunnen we de opgehaalde gegevens hergebruiken, wat uiteindelijk tijd bespaart tijdens de uitvoering van onze applicatie.

#### Browser Technologies
Mijn team en ik hebben voordat we begonnen aan de opdracht een doorgrondige de-briefing geschreven. Hiermee hebben we goed de core-functionaliteit van de app duidelijk gemaakt. Ik ben voornamelijk bezig geweest met het maken van de onboarding. Ik heb progressive enhancement toegevoegd zodat de onboarding ook zonder JavaScript zou moeten werken. Ook kunnen gebruikers van screenreaders door de verschillende onboarding schermen heen tabben. Verder heb ik in de onboarding goed gelet op leesbaarheid, visuele hiërarchie, contrast, keuzes in kleuren, gebruiksvriendelijkheid (de onboarding geeft feedback aan de gebruiker wanneer een veld niet is ingevult), etc.

#### Real-time Web
In onze applicatie wordt er gebruik gemaakt van een server-side API en een MongoDB-verbinding. De server bevat een datamodel en zorgt ervoor dat elke client de juiste gegevens ontvangt. Deze gegevens worden opgeslagen in de database en kunnen ook weer worden opgevraagd. Bovendien is er de mogelijkheid om het volledige object dat in de database is opgeslagen te verwijderen, waardoor je de onboarding procedure opnieuw kunt doorlopen.

#### Human Centered Design
We zijn wekelijks langs geweest (fysiek en online) bij de opdrachtgever om feedback te verzamelen op ons product en om ons product te laten testen. Deze feedback hebben we elke keer meegenomen in ons product. Verder staat de gebruiker in ons product centraal.

### Waar ik in ben verbeterd <a name="geleerd"></a>
Dankzij deze minor heb ik weer een opfrissing gehad in het schrijven van code. Ik wilde mezelf hier vele malen in verbeteren, in de hoop dat ik de dingen die ik geleerd heb toe kan passen in bijvoorbeeld het maken van web applicaties. Ik moet zeggen dat ik tijdens deze minor vooral heb gemerkt dat ik totaal geen achtergrond had in specifiek JavaScript. Ik dacht dat ik de basis kennis had, maar dit was duidelijk niet zo. Hierdoor liep ik wel erg vaak tegen blokken binnen de opdrachten die vooral gefocust waren op JavaScript, zoals Real Time Web en Progressive Web Apps. Ik heb wel geleerd hoe ik een applicatie omzet van client side naar server side. Ik heb geleerd hoe ik een API kan implementeren. Ik heb geleerd hoe ik aan de hand van progressive enhancement mijn websites beter beschikbaar kan maken voor iedereen die het web gebruikt. Ik heb geleerd hoe ik met een echt blind persoon kan werken en hoe ik dit persoon haar problemen kan oplossen aan de hand van een ontwerp. Ik heb geleerd met sockets te werken. Ik heb in de opleiding zelfs ruimte gehad om mijn vormgeving vaardigheden te verbeteren. Omdat ik zelf erg onervaren ben met specifiek JavaScript, heb ik wel het idee gehad dat ik te weinig tijd had om echt dieper in de lesstof te gaan, waardoor ik wel het idee heb dat ik nog een stuk meer moet oefenen om echt alles wat ik geleerd heb foutloos te kunnen implementeren. Al met al heb ik mijn code vaardigheden een stuk kunnen verbeteren.
